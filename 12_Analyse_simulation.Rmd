---
title: Analyse des simulations
subtitle: Parc naturel régional du Massif des Bauges
author: "Raphaël Aussenac, Jean-Matthieu MONNET"
date: "8 juin 2020"
output:
  html_document:
    self_contained: TRUE
    number_sections: true
    toc: true
    toc_depth: 2
  pdf_document:
    number_sections: true
fig_caption: yes
word_document: default
urlcolor: blue
---
  
```{r setup, include=FALSE}
rm(list=ls())
library(knitr)
knitr::opts_chunk$set(echo = TRUE, fig.width=12, fig.height=8)
# library(kableExtra)
#library(rgl)
#knit_hooks$set(webgl = hook_webgl)
options(scipen=999)
# wkhtmltopdf -B 15 -L 15 -R 15 -T 15 fiche-observatoire.html fiche-observatoire.pdf
# load packages
library(ggplot2)
library(plyr)
#
# set work directory
setwd("/home/jean-matthieu/R/PROTEST")
```

---
# Introduction {-}

L'objectif de ce document est de présenter les résultats de simulation réalisées par le logiciel SIMMEM sur le territoire du PNR du Massif des Bauges. 

La première partie décrit les conditions initiales du territoire simulé.
Le deuxième partie décrit les itinéraires simulés

```{r charge.donnees.initiales, echo=FALSE, warning=FALSE, message=FALSE}
# load full file
forestStands <- read.table("./output/forestStandsFULL.txt", header=TRUE, sep = '\t')
forestStands$WKT.GEOM <- as.character(forestStands$WKT.GEOM)
forestStands <- sf::st_sf(forestStands[,-which(names(forestStands)=="WKT.GEOM")], geom=sf::st_as_sfc(forestStands$WKT.GEOM))
sf::st_crs(forestStands) <- 2154
#
# format names
# typologie
levels(forestStands$typologie) <- gsub("Priv", "Privé", levels(forestStands$typologie))
levels(forestStands$typologie) <- gsub("Pub", "Public", levels(forestStands$typologie))
# gestion
levels(forestStands$gestion) <- gsub("AccGere", "Accessible-géré", levels(forestStands$gestion))
levels(forestStands$gestion) <- gsub("AccNonGere", "Accessible-non géré", levels(forestStands$gestion))
levels(forestStands$gestion) <- gsub("NonAcc", "Non accessible", levels(forestStands$gestion))
levels(forestStands$gestion) <- gsub("NonBuch", "Non bûcheronnable", levels(forestStands$gestion))
# itineraire
forestStands$itineraire <- factor(ifelse(substr(forestStands$COMMENT,1,2)=="Co", "Inaction",
                                  ifelse(substr(forestStands$COMMENT,1,2)=="Ir", "Irrégulier",
                                         ifelse(substr(forestStands$COMMENT,1,2)=="Th", "Amélioration","Coupe rase"))))
```

Le nombre de polygones simulés est de `r nrow(forestStands)`, pour une surface totale de `r round(sum(forestStands$AREA)/10000,-1)` ha. Leurs caractéristiques sont présentées dans les paragraphes suivants.

# Description générale du territoire

## Typologie des polygones

La typologie des peuplements résulte d'un croisement entre la propriété (qui oriente partiellement la sylviculture) et la composition en essence (qui détermine le paramétrage de la croissance et oriente partiellement la sylviculture).

Les types de polygones sont présentés sur les graphiques suivants.

```{r typologie, echo=FALSE, warning=FALSE, message=FALSE}
# gestion et type de peuplements
tab.typo.gestion <- as.data.frame.matrix(questionr::wtd.table(forestStands$typologie, forestStands$gestion, weights = forestStands$AREA/10000, digits=0))
tab.typo.gestion <- as.matrix(t(tab.typo.gestion))
#
tab.typo <- apply(tab.typo.gestion, 2, sum)
pie(tab.typo, col=c("red", "orange", "green", "cyan", "darkgreen", "blue"), labels=paste(names(tab.typo), round(tab.typo/sum(tab.typo)*100, 1)))
plot(forestStands["typologie"], border=NA, key.pos=NULL, pal=c("red", "orange", "green", "cyan", "darkgreen", "blue"), main="Typologie des peuplements")
```

## Accessibilité et gestion

Selon les conditions d'accessibilité du polygone, la propriété et la surface moyenne des parcelles cadastrales qu'il contient (pour la propriété privée), il peut être géré ou non.

```{r accessibilite, echo=FALSE, warning=FALSE, message=FALSE}
tab.gestion <- apply(tab.typo.gestion, 1, sum)
pie(tab.gestion, col=c("green", "blue", "pink", "purple"), labels=paste(c("Accessible géré", "Accessible non géré", "Non débardable", "Non bûcheronnable"), round(tab.gestion/sum(tab.gestion)*100, 1)))
```

La répartition des catégories de peuplements selon la gestion (ou non) est présentée dans les figures ci-dessous.

```{r gestion.typo, echo=FALSE, warning=FALSE, message=FALSE}
par(mar=c(7,4,2,2))
par(mfrow=c(1,2))
barplot(tab.typo.gestion, col=c("green", "blue", "pink", "purple"), las=2, cex.names=0.8, main="Surface (ha)")
# legend("topright", c("Accessible géré", "Accessible non géré", "Non débardable", "Non bûcheronnable"), fill=c("green", "blue", "pink", "purple"), cex=0.7)
barplot(apply(tab.typo.gestion, 2, function(x){x/sum(x)*100}), width=apply(tab.typo.gestion, 2, sum), col=c("green", "blue", "pink", "purple"), las=2, cex.names=0.8, main="Pourcentage")
```

## Itinéraires sylvicoles

Selon la catégorie du polygone, il lui est appliqué un itinéraire sylvicole. Ceux-ci sont présentés ensuite. 

```{r itineraire, echo=FALSE, warning=FALSE, message=FALSE}
# gestion et type de peuplements
tab.typo.itineraire <- as.data.frame.matrix(questionr::wtd.table(forestStands$typologie, forestStands$itineraire, weights = forestStands$AREA/10000, digits=0))
tab.typo.itineraire <- as.matrix(t(tab.typo.itineraire))
tab.typo.itineraire <- tab.typo.itineraire[c(2,1,4,3),]
#
tab.itineraire <- apply(tab.typo.itineraire, 1, sum)
pie(tab.itineraire, col=c("red", "orange", "yellow", "darkgrey"), labels=paste(names(tab.itineraire), round(tab.itineraire/sum(tab.itineraire)*100, 1)), main="Pourcentage des itinéraires")
plot(forestStands["itineraire"], pal=c("orange", "red", "darkgrey", "yellow"), border=NA, key.pos=1)
```

La répartition des itinéraires par catégorie de polygone figure ci-dessous.

```{r itineraire.typo, echo=FALSE, warning=FALSE, message=FALSE}
par(mar=c(7,4,2,2))
par(mfrow=c(1,2))
barplot(tab.typo.itineraire, col=c("red", "orange", "yellow", "darkgrey"), las=2, cex.names = 0.8, main="Surface (ha)")
# legend("topright", row.names(tab.typo.itineraire), fill=c("orange", "red", "darkgrey", "yellow"))
barplot(apply(tab.typo.itineraire, 2, function(x){x/sum(x)*100}), width=apply(tab.typo.itineraire, 2, sum), col=c("red", "orange", "yellow", "darkgrey"), las=2, cex.names = 0.8, main="Pourcentage")
```

## Dendrométrie des polygones par itinéraire et catégorie de peuplement 

Les graphiques suivants montrent les valeurs initiales de RDI et Dg pour les itinéraires et sous-itinéraires appliqués aux différentes catégories de peuplement.

```{r rdi, echo=FALSE, warning=FALSE, message=FALSE}
# État initial des peuplements
# summary(forestStands[,-26])
# hist(forestStands$RDI)
# boxplot(RDI~gestion, data=forestStands, las=2)
# boxplot(RDI~COMMENT, data=forestStands)
#
# test <- aggregate(AREA~COMMENT, data)
for (i in levels(forestStands$itineraire))
{
  par(mar=c(9.5,4,2,2))
  par(mfrow=c(1,2))
  par(las=2)
  dummy <- forestStands[forestStands$itineraire==i,]
  dummy$COMMENT <- factor(dummy$COMMENT)
  levels(dummy$COMMENT) <- substr(levels(dummy$COMMENT), ifelse(is.element(i, c("Inaction", "Coupe rase")), 4, 3), 100)
  levels(dummy$COMMENT) <- gsub("bfs","Mixte", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("fsp","Sapin-épicéa", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("oak","Chêne", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("bee","Hêtre", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("Pu","_Public", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("Pr","_Privé", levels(dummy$COMMENT))
  levels(dummy$COMMENT) <- gsub("PP","", levels(dummy$COMMENT))
  test <- aggregate(AREA~COMMENT, data=dummy, FUN=sum)
  boxplot(RDI~COMMENT, data=dummy, xlab="", width=test$AREA, main=paste0("RDI ",i))#, xaxt="n")
  # if (i=="Coupe rase") {abline(h=1.5, col="blue");abline(h=c(1.5-0.05, 1.5+0.05), col="blue", lty=2)}
  if (i=="Amélioration") {abline(h=c(0.6, 0.7), col="blue");abline(h=c(0.55, 0.65, 0.75), col="blue", lty=2)}
  if (i=="Irrégulier") {abline(h=c(0.5, 0.7, 0.9), col="blue");abline(h=c(0.4, 0.6, 0.8), col="blue", lty=2)}
  abline(h=1, col="red", lty=3)
  #
  boxplot(Dgtot~COMMENT, data=dummy, xlab="", width=test$AREA, main=paste0("Dg ",i))#, xaxt="n")
  if (i=="Coupe rase") {points(c(1,2,3), c(30, 40, 30),col="blue", pch=3)}
  if (i=="Amélioration") {points(c(1,2,3,4, 6, 7,8,9, 3,5,8,10), c(rep(40,8), rep(50, 4)),col="blue", pch=3)}
}
```

# Simulations

```{r charger.simus, echo=FALSE, warning=FALSE, message=FALSE}
#
# simulation parameters
# 
duration <- 30
# time step = 3 yrs
timeStep <- 3
#
# load SIMMEM output file
df <- read.csv(file="./simmem/simmemOutput/exportAutoBAU.txt", sep = "\t", skip = 3)
colnames(df)[1] <- "standId"
#
# load SIMMEM input file to retrieve plot surface
# forestStands <- read.csv(file="./output/forestStands.txt", sep = "\t", skip = 8)
# colnames(forestStands)[1] <- "STAND_ID"

###############################################################
# manage format
###############################################################

# create columns for sp2
df$realSpecies2 <- -1
df$Ddom2 <- -1

# separate sp1 and sp2 data
df[df$realSpecies == 'Fagus sylvatica;Picea abies', 'realSpecies2'] <- 'Picea abies'
df[df$realSpecies == 'Fagus sylvatica;Abies alba', 'realSpecies2'] <- 'Abies alba'
df[df$realSpecies == 'Abies alba;Picea abies', 'realSpecies2'] <- 'Picea abies'

colnames(df)[colnames(df) == "realSpecies"] <- "realSpecies1"
df[df$realSpecies1 == 'Fagus sylvatica;Picea abies', 'realSpecies1'] <- 'Fagus sylvatica'
df[df$realSpecies1 == 'Fagus sylvatica;Abies alba', 'realSpecies1'] <- 'Fagus sylvatica'
df[df$realSpecies1 == 'Abies alba;Picea abies', 'realSpecies1'] <- 'Abies alba'

# TODO: separate Ddom1 and Ddom2

# retrieve area
df <- merge(df, forestStands[,c("STAND_ID", "AREA")], by.x = "standId", by.y = "STAND_ID")
# managType
df$managType <- substr(df$comment, 1, 3)
# compo
df$compo <- substr(df$comment, 4, 6)
# owner
df$owner <- substr(df$comment, 7, 8)
# order by standId and then by date
df <- df[order(df$standId, df$date), ]
```
On s'intéresse à une durée simulée de `r duration` années. 

Dans le cas de la coupe rase, SIMMEM répète à chaque intervalle les valeurs du dernier volume exploité dans le fichier de sortie. Les valeurs en doublon sont enlevées du tableau de résultats. La dernière année simulée, aucune exploitation n'est réalisée, les valeurs de cette année sont enlevées.

Dans le fichier de sortie de SIMEMM, une ligne par année est indiquée. La première année reprend les valeurs initiales. Une intervention est éventuellement déclenchée dès la première année. Ce sont donc les caractéristiques du peuplement avant intervention qui sont indiquées. Les caractéristiques du peuplement après intervention ne sont pas disponibles, la ligne suivante présentant les caractéristiques du peuplement après intervention éventuelle et croissance du peuplement pendant la période de simulation suivante.

```{r enlever.doublons.exploitation, echo=FALSE, warning=FALSE, message=FALSE}
###############################################################
# remove repeated clearcut
###############################################################
if(1)
{
  # order df by standid then date
  df <- df[order(df$standId, df$date),]
  testStand <- df$standId[1:(nrow(df)-1)]==df$standId[2:nrow(df)]
  testYear <- df$date[1:(nrow(df)-1)]==df$date[2:nrow(df)]-3
  testVolume <- df$volumeRemoved_m3[1:(nrow(df)-1)]==df$volumeRemoved_m3[2:nrow(df)]
  testVolumeZero <- df$volumeRemoved_m3[-nrow(df)]!=0
  testManagTyp <- df$managType[-nrow(df)]=="Har"
  # testBasalArea <- df$basalArea_m2[1:(nrow(df)-1)]>=df$basalArea_m2[2:nrow(df)]
  falseVolume <- which(testStand & testVolume & testVolumeZero & testYear)
  df$volumeRemoved_m3[falseVolume+1] <- 0
  #
  # test volume removed while ba increases
  # which(df$basalArea_m2[1:(nrow(df)-1)]<=df$basalArea_m2[2:nrow(df)] & df$volumeRemoved_m3[-nrow(df)] >0)
  # 
  # sum(df$volumeRemoved_m3[df$managType=="Har"])
}

# remove last year
df <- df[df$date!=max(df$date),]

# keep only 30 years
df <- df[df$date<min(df$date)+duration,]
```

Les graphiques suivantes montrent l'évolution du RDI et du Dg pour chaque polygone, pour les différentes catégories et itinéraires.

```{r evolution.G, echo=FALSE, warning=FALSE, message=FALSE}
###############################################################
# density (rdi)
###############################################################
df$standColor <- as.numeric(as.factor(df$standId))
# RDI
ggplot(data = df, aes(x = date, y = density_01, group = standId, col = standId)) +
  geom_line() +
  scale_color_gradient2(low="blue", mid="green", high="red", midpoint = mean(df$standColor)) +
  # geom_point() +
  facet_grid(compo ~ managType)
```

```{r evolution.G, echo=FALSE, warning=FALSE, message=FALSE}
###############################################################
# basal area
###############################################################
ggplot(data = df, aes(x = date, y = basalArea_m2, group = standId, col = standId)) +
  geom_line() +
  scale_color_gradient2(low="blue", mid="green", high="red", midpoint = mean(df$standColor)) +
  # geom_point() +
  facet_grid(compo ~ managType)
```

```{r evolution.final, echo=FALSE, warning=FALSE, message=FALSE}
# ###############################################################
# # Annual volume removed
# ###############################################################
# 
# 
# 
# # multiply volume * area / 3 yrs
# df$annualVolumeRemoved_m3 <- df$volumeRemoved_m3 * (df$AREA / 10000) / timeStep
# 
# # total volume removed each year
# voltot <- ddply(df[df$volumeRemoved_m3 > 0,], .(date), summarise, vol = sum(annualVolumeRemoved_m3))
# plot(voltot$vol ~ voltot$date, pch = 16, ylab = "volume exploité ou éclairci", xlab = "")
# lines(voltot$vol ~ voltot$date)
# 
# # volume removed each year for each managtype
# voltot <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, managType), summarise, vol = sum(annualVolumeRemoved_m3))
# ggplot(data = voltot, aes(x = date, y = vol, group = managType, col = managType)) +
#   geom_line() +
#   geom_point()
# 
# # volume removed each year for each compo type
# voltot <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, compo), summarise, vol = sum(annualVolumeRemoved_m3))
# ggplot(data = voltot, aes(x = date, y = vol, group = compo, col = compo)) +
#   geom_line() +
#   geom_point()
# 
# # volume removed each year for each ownership type
# voltot <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, domainType), summarise, vol = sum(annualVolumeRemoved_m3))
# ggplot(data = voltot, aes(x = date, y = vol, group = domainType, col = domainType)) +
#   geom_line() +
#   geom_point()
# 
# # volume removed each year for each managtype and compo
# vol <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, managType, compo), summarise, vol = sum(annualVolumeRemoved_m3))
# ggplot(data = vol, aes(x = date, y = vol, group = compo)) +
#   geom_line() +
#   geom_point() +
#   facet_grid(compo ~ managType)
# 
# ###############################################################
# # Annual surface harvested/thinned
# ###############################################################
# 
# # time step = 3 yrs
# df$annualAREA <- (df$AREA / 10000) / timeStep
# df[df$annualVolumeRemoved_m3 == 0, "annualAREA"] <- 0
# 
# # total area harvested/thinned each year
# areatot <- ddply(df[df$volumeRemoved_m3 > 0,], .(date), summarise, area = sum(annualAREA))
# plot(areatot$area ~ areatot$date, pch = 16, ylab = "surface exploitée - éclaircie", xlab = "")
# lines(areatot$area ~ areatot$date)
# 
# # total area harvested/thinned each year for each managType
# area <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, managType), summarise, area = sum(annualAREA))
# ggplot(data = area, aes(x = date, y = area, group = managType, col = managType)) +
#   geom_line() +
#   geom_point()
# 
# # surface harvested each year for each ownership type
# areaPP <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, domainType), summarise, area = sum(annualAREA))
# ggplot(data = areaPP, aes(x = date, y = area, group = domainType, col = domainType)) +
#   geom_line() +
#   geom_point()
# 
# # surface harvested each year for each ownership type for Har scenario
# areaPP <- ddply(df[df$volumeRemoved_m3 > 0 & df$managType=="Th2" & df$compo=="bfs",], .(date, domainType), summarise, area = sum(annualAREA))
# ggplot(data = areaPP, aes(x = date, y = area, group = domainType, col = domainType)) +
#   geom_line() +
#   geom_point()
# 
# # surface harvested each year for each compo type
# areaPP <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, compo), summarise, area = sum(annualAREA))
# ggplot(data = areaPP, aes(x = date, y = area, group = compo, col = compo)) +
#   geom_line() +
#   geom_point()
# 
# # total area harvested/thinned each year for each managType and compo
# area <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, managType, compo), summarise, area = sum(annualAREA))
# ggplot(data = area, aes(x = date, y = area, group = managType)) +
#   geom_line() +
#   geom_point() +
#   facet_grid(compo ~ managType)
# 
# #
# ##############################################
# 
# #
# # mean annual harvest over interest duration
# dummy <- df[df$date<min(df$date+duration),]
# dummy <- lapply(split(dummy$volumeRemoved_m3, dummy$standId),
#                  FUN=function(x)
#                  {
#                    mean.operation.per.year <- sum(x>0)/duration
#                    mean.volume.per.operation <- mean(x[x>0])
#                    mean.volume.per.year <- sum(x)/duration
#                    data.frame(mean.operation.per.year, mean.volume.per.operation, mean.volume.per.year)
#                  }
# )
# dummy.names <- names(dummy)
# dummy <- do.call(rbind, dummy)
# dummy$STAND_ID <- dummy.names
# #
# forestStands <- merge(forestStands, dummy)
# # put 0 to plots without operations
# forestStands$mean.volume.per.operation[is.na(forestStands$mean.volume.per.operation)] <- 0
# 
# sf::st_write(forestStands["STAND_ID"], "./output/forestStandsSimulatedPolygons.shp", delete_layer=TRUE)
# setwd("./output")
# write.table(sf::st_drop_geometry(forestStands), sep=";", row.names=FALSE, file="forestStandsSimulatedData.csv")
# #
# ###########################################
# #
# # recap varies et interessants
# #
# durationsubset <- which(df$date<min(df$date+duration))
# mean(aggregate(df$annualAREA, list(df$date), FUN=sum)$x)
# mean(aggregate(df$annualVolumeRemoved_m3, list(df$date), FUN=sum)$x)
# #
# 
# 
# # volumes et surface traités
# # total area harvested/thinned each year for each managType and compo
# df$iti <- substr(df$managType, 1, 2)
# area <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, iti, compo, domainType), summarise, area = sum(annualAREA))
# ggplot(data = area, aes(x = date, y = area, group = domainType, col=domainType)) +
#   geom_line() +
#   #geom_point() +
#   facet_grid(compo ~ iti)
# 
# # total vol harvested/thinned each year for each managType and compo
# vol <- ddply(df[df$volumeRemoved_m3 > 0,], .(date, iti, compo, domainType), summarise, vol = sum(annualVolumeRemoved_m3))
# ggplot(data = vol, aes(x = date, y = vol, group = domainType, col=domainType)) +
#   geom_line() +
#   #geom_point() +
#   facet_grid(compo ~ iti)
# 
# managed.plots <- which(substr(forestStands$COMMENT, 1, 3)!="Con")
# # récolte moyenne annuelle
# plotrix::weighted.hist(forestStands$mean.volume.per.year[managed.plots], forestStands$AREA[managed.plots]/10000, xlab="Volume (m3/ha/an)", ylab="Surface (ha)", main="Récolte moyenne pour les parcelles gérées", breaks=seq(from=0, to=37.5, by=2.5))
# # récolte moyenne par parcelle (pondérée par surface et nombre d'opération)
# plotrix::weighted.hist(forestStands$mean.volume.per.operation[managed.plots], forestStands$AREA[managed.plots]*forestStands$mean.operation.per.year[managed.plots]/10000, xlab="Volume (m3/ha)", ylab="Surface (ha)", main="Récolte moyenne par opération, par parcelle")
# 
# # récolte par type d'itinéraire
# for (i in c("Ha", "Ir", "Th"))
# {
#   hist(df$volumeRemoved_m3[df$iti==i & df$volumeRemoved_m3>0], main=i, xlab="Prélèvement (m3/ha)", ylab="Nb de coupes")
# }
# 
# if (0)
# {
#   # table EXPLOITABILITY / silviculture
#   test <- as.data.frame.matrix(questionr::wtd.table(forestStands$COMMENT, forestStands$EXPLOITABILITY, weights = forestStands$AREA/10000, digits=0))
#   round(test,0)
#   # table Gestion / silviculture
#   test <- as.data.frame.matrix(questionr::wtd.table(forestStands$gestion, forestStands$COMMENT, weights = forestStands$AREA/10000, digits=0))
#   round(test,0)
#   # table stand type / silviculture
#   test <- as.data.frame.matrix(questionr::wtd.table(forestStands$typologie, forestStands$COMMENT, weights = forestStands$AREA/10000, digits=0))
#   round(test,0)
#   # table stand type / silviculture type
#   test <- as.data.frame.matrix(questionr::wtd.table(forestStands$typologie, substr(forestStands$COMMENT,1,3), weights = forestStands$AREA/10000, digits=0))
#   round(test,0)
#   # table gestion / silviculture type
#   test <- as.data.frame.matrix(questionr::wtd.table(forestStands$gestion, substr(forestStands$COMMENT,1,3), weights = forestStands$AREA/10000, digits=0))
#   round(test,0)
#   # table owner / silviculture
#   test <- as.data.frame.matrix(questionr::wtd.table(forestStands$DOMAINE_TYPE, forestStands$COMMENT, weights = forestStands$AREA/10000, digits=0))
#   round(test,0)
#   # table gestion / silviculture
#   test <- as.data.frame.matrix(questionr::wtd.table(forestStands$gestion, forestStands$COMMENT, weights = forestStands$AREA/10000, digits=0))
#   round(test,0)
# }
```